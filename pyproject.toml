# pyproject.toml

# PEP 517: Specifies the build system for the project.
# Hatchling is a modern, standards-compliant build backend.
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

# PEP 621: Core project metadata.
# This information is used by packaging tools and displayed on PyPI.
# Jinja2 templates are used here to insert values from copier.yml.
[project]
name = "{{ project_name | slugify }}"
description = "{{ project_description }}"
readme = "README.md"
requires-python = ">=3.8"
license = { file = "LICENSE" }
keywords = ["cli", "copier", "template"]
authors = [
  { name = "{{ author_name }}", email = "{{ author_email }}" },
]
classifiers = [
  "Development Status :: 3 - Alpha",
  "Intended Audience :: Developers",
  "License :: OSI Approved :: MIT License",
  "Programming Language :: Python",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3 :: Only",
  "Programming Language :: Python :: 3.8",
  "Programming Language :: Python :: 3.9",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Topic :: Software Development :: Libraries :: Application Frameworks",
]
# Runtime dependencies for the application.
dependencies = [
  "typer[all]>=0.12.3",
]

# Optional dependency groups exposed for tooling.
[project.optional-dependencies]
dev = [
  "bandit",
  "mypy",
  "pytest",
  "pytest-cov[toml]",
  "ruff",
]

# Defines the command-line script entry point.
# When the package is installed, a command named after the project will be
# available, which executes the `app` function in the `cli` module.
[project.scripts]
"{{ project_name | slugify }}" = "{{ project_name | slugify }}.cli:app"

# Project URLs to be displayed on PyPI.
[project.urls]
Homepage = "https://github.com/your-username/{{ project_name | slugify }}"
"Bug Tracker" = "https://github.com/your-username/{{ project_name | slugify }}/issues"
Repository = "https://github.com/your-username/{{ project_name | slugify }}"

# --- Hatch Configuration ---
# Hatch is used for project management, environment management, and task running.

# Configures Hatch to source the project version from the package's __init__.py.
# This enables single-sourcing the version number.
[tool.hatch.version]
path = "src/{{ project_name | slugify }}/__init__.py"

# Configures the wheel build target to correctly handle the 'src' layout.
# It tells Hatchling where to find the importable package directory.
[tool.hatch.build.targets.wheel]
packages = ["src/{{ project_name | slugify }}"]

# Configuration for Hatch environments.
[tool.hatch.envs.default]
# Specifies 'uv' as the installer for virtual environments. This significantly
# speeds up dependency installation and resolution.
installer = "uv"
# Dependencies required for development, linting, testing, etc.
# These are installed into the default Hatch environment.
dependencies = [
  "ruff",
  "mypy",
  "bandit",
  "pytest",
  "pytest-cov[toml]",
]

# Defines runnable scripts within the Hatch environment.
# These scripts are the single source of truth for all quality checks.
[tool.hatch.envs.default.scripts]
# Linter/Formatter scripts
lint = "ruff format src tests"
lint-check = "ruff check src tests"

# Type checking script
type-check = "mypy ."

# Security analysis script
security = "bandit -c pyproject.toml -r src"

# Testing script
test = "pytest"

# Master script to run all checks in sequence.
# This is used by the Makefile and the CI pipeline to ensure consistency.
check-all = [
  "lint-check",
  "type-check",
  "security",
  "test",
]

# --- Tool Configurations ---
# All tool configurations are centralized here for maintainability.

# Ruff (Linter and Formatter) Configuration
[tool.ruff]
line-length = 88
target-version = "py38"

[tool.ruff.lint]
# A strict selection of rules for high code quality.
select = ["A", "B", "C4", "E", "F", "I", "N", "S", "TID", "UP"]
ignore = []

# Enforces Google-style docstrings, a non-negotiable requirement.
[tool.ruff.lint.pydocstyle]
convention = "google"

[tool.ruff.format]
quote-style = "double"

# MyPy (Static Type Checker) Configuration
[tool.mypy]
strict = true
ignore_missing_imports = true
# Allow redefinition for typer callbacks/options which can look like redefinitions
allow_redefinition = true
# Exclude virtual environment directories from checks
exclude = '(\\.venv|\\.hatch)'

# Bandit (Security Scanner) Configuration
[tool.bandit]
exclude_dirs = ["tests"]
skips = ["B101"] # Skip assert_used check, common in tests

# Pytest Configuration
[tool.pytest.ini_options]
minversion = "6.0"
# Default arguments for pytest.
# -ra: show extra test summary info
# -q: quiet mode
# --cov: enable coverage reporting for the specified package
# --cov-report: specify coverage report format
# --cov-fail-under: fail the test run if coverage is below the threshold
addopts = "-ra -q --cov={{ project_name | slugify }} --cov-report=term-missing --cov-fail-under=80"
testpaths = [
  "tests",
]

# Coverage.py Configuration
[tool.coverage.run]
source = ["{{ project_name | slugify }}"]
# Omit test files from the coverage source to avoid skewing results.
omit = ["tests/*"]

[tool.coverage.report]
# Fail if coverage is below 80%. This value is duplicated from addopts
# to ensure it's respected by `coverage report` commands as well.
fail_under = 80
exclude_lines = [
  "if __name__ == \"__main__\":",
]
